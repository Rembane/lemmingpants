SET SCHEMA 'api';

-- Common types -------------------------------------------------------------
CREATE TYPE state AS ENUM ('init', 'active', 'done');

-- Public tables ------------------------------------------------------------
CREATE TABLE attendee (
    id      INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    cid     TEXT NOT NULL,
    name    TEXT NOT NULL,
    nick    TEXT NULL,
    created TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
GRANT SELECT, INSERT ON attendee TO insert_attendee_user, admin_user, web_anon;

CREATE TABLE agenda_item (
    id      INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title   TEXT NOT NULL,
    content TEXT NOT NULL,
    order_  INTEGER GENERATED BY DEFAULT AS IDENTITY,
    state   state DEFAULT 'init' NOT NULL
);
-- Only one agenda item may be active at the time.
CREATE UNIQUE INDEX ON agenda_item (state) WHERE state='active';

GRANT SELECT ON agenda_item TO admin_user, insert_attendee_user, web_anon;
GRANT UPDATE ON agenda_item TO admin_user;
GRANT REFERENCES ON agenda_item TO admin_user;

CREATE TABLE speaker_queue (
    id             INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    agenda_item_id INTEGER REFERENCES agenda_item NOT NULL,
    state          state DEFAULT 'init' NOT NULL
);
REVOKE ALL ON TABLE speaker_queue FROM admin_user, insert_attendee_user, web_anon, PUBLIC;
GRANT INSERT (agenda_item_id, state) ON speaker_queue TO admin_user;
GRANT UPDATE (state) ON speaker_queue TO admin_user;
GRANT REFERENCES ON speaker_queue TO admin_user;
GRANT SELECT ON speaker_queue TO admin_user, web_anon;

CREATE TABLE speaker (
    id               INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    speaker_queue_id INTEGER REFERENCES speaker_queue NOT NULL,
    attendee_id      INTEGER REFERENCES attendee NOT NULL,
    state            state DEFAULT 'init' NOT NULL,
    created          TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
-- At most one speaker per queue may be active at the time.
CREATE UNIQUE INDEX ON speaker (speaker_queue_id, state) where state='active';

REVOKE ALL ON TABLE speaker FROM admin_user, insert_attendee_user, web_anon, PUBLIC;
GRANT INSERT (speaker_queue_id, attendee_id, state) ON speaker TO admin_user;
GRANT UPDATE (state) ON speaker TO admin_user;
GRANT REFERENCES ON speaker TO admin_user;
GRANT SELECT ON speaker TO admin_user, web_anon;

-- This is used to determine the order of the speakers.
-- It lets us have an infinite number of speakers queues.
CREATE VIEW speaker_count AS
    SELECT speaker_queue_id, attendee_id, COUNT(*) AS times_spoken
    FROM speaker
    WHERE state = 'done'
    GROUP BY (speaker_queue_id, attendee_id);

GRANT SELECT ON speaker_count TO admin_user, web_anon;

CREATE VIEW active_speakers AS
  SELECT s.id, s.speaker_queue_id, s.attendee_id, s.state, COALESCE(sc.times_spoken, 0) AS times_spoken
  FROM speaker AS s
  LEFT JOIN speaker_count AS sc
  ON    s.attendee_id      = sc.attendee_id
  AND   s.speaker_queue_id = sc.speaker_queue_id
  WHERE s.state = 'init' OR s.state = 'active'
  ORDER BY times_spoken, s.id;

GRANT SELECT ON active_speakers TO admin_user, web_anon;

-- Triggers -----------------------------------------------------------------
CREATE FUNCTION create_speaker_queue() RETURNS TRIGGER
    LANGUAGE plpgsql
    AS $$
    BEGIN
      INSERT INTO speaker_queue(agenda_item_id) VALUES(NEW.id);
      RETURN NULL;
    END
    $$;

CREATE TRIGGER at_least_one_speakerqueue
    AFTER INSERT ON agenda_item
    FOR EACH ROW
    EXECUTE PROCEDURE create_speaker_queue();

-- TODO: Make this work for the speaker table too.
-- It doesn't make any sense to add a speaker to a speakerqueue that isn't on the top of the stack.
CREATE FUNCTION check_if_top_speakerqueue() RETURNS TRIGGER
    LANGUAGE plpgsql
    AS $$
    DECLARE
        has_greater_friends BOOLEAN;
    BEGIN
        SELECT COUNT(sq2.id) > 0 INTO STRICT has_greater_friends
            FROM speaker_queue AS sq1
            JOIN speaker_queue AS sq2
            ON sq2.state = 'active'
            AND sq2.id > OLD.id
            AND sq1.agenda_item_id = sq2.agenda_item_id
            WHERE sq1.id = OLD.id;

        IF has_greater_friends
            THEN
                RAISE WARNING 'This speaker queue is not on top of the stack!';
                RETURN OLD;
            ELSE
                RETURN NEW;
            END IF;
    END
    $$;

CREATE TRIGGER only_update_top_speakerqueue
    BEFORE UPDATE OF state ON speaker_queue
    FOR EACH ROW
    EXECUTE PROCEDURE check_if_top_speakerqueue();

-- API RPC functions --------------------------------------------------------

-- Returns the id of the new current agenda item if things worked out well, 0 otherwise.
CREATE FUNCTION set_current_agenda_item(id INTEGER) RETURNS INTEGER
    LANGUAGE plpgsql
    AS $$
    DECLARE
        n INTEGER = 0;
    BEGIN
        IF EXISTS(SELECT 1 FROM agenda_item WHERE agenda_item.id=set_current_agenda_item.id) THEN
            UPDATE agenda_item SET state='done' WHERE state='active';
            UPDATE agenda_item SET state='active' WHERE agenda_item.id=set_current_agenda_item.id RETURNING agenda_item.id INTO n;
            RETURN n;
        ELSE
            RETURN 0;
        END IF;
    END
    $$;

REVOKE ALL ON FUNCTION set_current_agenda_item(id INTEGER) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION set_current_agenda_item(id INTEGER) TO admin_user;

-- Returns the id of the new current speaker if things worked out well, 0 otherwise.
CREATE FUNCTION set_current_speaker(id INTEGER) RETURNS INTEGER
    LANGUAGE plpgsql
    AS $$
    DECLARE
        n INTEGER = 0;
    BEGIN
        IF EXISTS(SELECT 1 FROM speaker WHERE speaker.id=set_current_speaker.id) THEN
            UPDATE speaker SET state='done' WHERE state='active';
            UPDATE speaker SET state='active' WHERE speaker.id=set_current_speaker.id RETURNING speaker.id INTO n;
            RETURN n;
        ELSE
            RETURN 0;
        END IF;
    END
    $$;

REVOKE ALL ON FUNCTION set_current_speaker(id INTEGER) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION set_current_speaker(id INTEGER) TO admin_user;

-- Public facing auth functions ---------------------------------------------

CREATE TYPE jwt_token AS (token TEXT);

CREATE FUNCTION api.login(username TEXT, password TEXT) RETURNS jwt_token
    LANGUAGE sql SECURITY DEFINER SET search_path = api, model, public, pg_temp
    AS $$
        -- Sign encrypts using HS256 by default.
        SELECT sign(row_to_json(r), current_setting('app.jwt_secret')) AS token FROM (
            SELECT
                role.name::TEXT AS role,
                extract(EPOCH FROM NOW())::INTEGER + 3600 AS exp
            FROM model.role
            RIGHT OUTER JOIN model.users ON (model.role.id = model.users.role_id)
            WHERE (username=username AND pwhash=model.crypt(password, pwhash))
        ) r;
    $$;

REVOKE ALL ON FUNCTION login(username TEXT, password TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION login(username TEXT, password TEXT) TO web_anon, lemmingpants;

