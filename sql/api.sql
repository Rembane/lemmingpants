SET SCHEMA 'api';

-- Common types -------------------------------------------------------------
CREATE TYPE state AS ENUM ('init', 'active', 'done');

-- Public tables and views --------------------------------------------------
CREATE TABLE attendee (
    id      INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    cid     TEXT NOT NULL,
    name    TEXT NOT NULL,
    nick    TEXT NULL,
    created TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
GRANT SELECT, INSERT ON attendee TO insert_attendee_user, admin_user, web_anon;

CREATE TABLE agenda_item (
    id      INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title   TEXT NOT NULL,
    content TEXT NOT NULL,
    order_  INTEGER GENERATED BY DEFAULT AS IDENTITY,
    state   state DEFAULT 'init' NOT NULL
);
-- Only one agenda item may be active at the time.
CREATE UNIQUE INDEX ON agenda_item (state) WHERE state='active';

GRANT SELECT ON agenda_item TO admin_user, insert_attendee_user, web_anon;
GRANT UPDATE ON agenda_item TO admin_user;
GRANT REFERENCES ON agenda_item TO admin_user;

CREATE TABLE speaker_queue (
    id             INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    agenda_item_id INTEGER REFERENCES agenda_item NOT NULL,
    state          state DEFAULT 'init' NOT NULL
);
REVOKE ALL ON TABLE speaker_queue FROM admin_user, insert_attendee_user, web_anon, PUBLIC;
GRANT INSERT (agenda_item_id, state) ON speaker_queue TO admin_user;
GRANT UPDATE (state) ON speaker_queue TO admin_user;
GRANT REFERENCES ON speaker_queue TO admin_user;
GRANT SELECT ON speaker_queue TO admin_user, web_anon;

CREATE TABLE speaker (
    id               INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    speaker_queue_id INTEGER REFERENCES speaker_queue NOT NULL,
    attendee_id      INTEGER REFERENCES attendee NOT NULL,
    state            state DEFAULT 'init' NOT NULL,
    created          TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
-- At most one speaker per queue may be active at the time.
CREATE UNIQUE INDEX ON speaker (speaker_queue_id, state) where state='active';

REVOKE ALL ON TABLE speaker FROM admin_user, insert_attendee_user, web_anon, PUBLIC;
GRANT INSERT (speaker_queue_id, attendee_id, state) ON speaker TO admin_user;
GRANT UPDATE (state) ON speaker TO admin_user;
GRANT REFERENCES ON speaker TO admin_user;
GRANT SELECT ON speaker TO admin_user, web_anon;

-- This is used to determine the order of the speakers.
-- It lets us have an infinite number of speakers queues.
CREATE VIEW speaker_count AS
    SELECT speaker_queue_id, attendee_id, COUNT(*) AS times_spoken
    FROM speaker
    WHERE state = 'done'
    GROUP BY (speaker_queue_id, attendee_id);

GRANT SELECT ON speaker_count TO admin_user, web_anon;

-- Note that if a speaker hasn't spoken, this view will simply give you
-- times_spoken = 0. You can even in that case use this table without
-- fear as long as you give a speaker id as a ritual sacrifice.
CREATE VIEW active_speakers AS
  SELECT s.id, s.speaker_queue_id, s.attendee_id, s.state, COALESCE(sc.times_spoken, 0) AS times_spoken
  FROM speaker AS s
  LEFT JOIN speaker_count AS sc
  ON    s.attendee_id      = sc.attendee_id
  AND   s.speaker_queue_id = sc.speaker_queue_id
  WHERE s.state = 'init' OR s.state = 'active'
  ORDER BY times_spoken, s.id;

GRANT SELECT ON active_speakers TO admin_user, web_anon;

-- Triggers -----------------------------------------------------------------
CREATE FUNCTION create_speaker_queue() RETURNS TRIGGER
    LANGUAGE plpgsql
    AS $$
    BEGIN
      INSERT INTO speaker_queue(agenda_item_id) VALUES(NEW.id);
      RETURN NULL;
    END
    $$;

CREATE TRIGGER create_speakerqueue_when_agenda_item_is_created
    AFTER INSERT ON agenda_item
    FOR EACH ROW
    EXECUTE PROCEDURE create_speaker_queue();

CREATE FUNCTION at_least_one_speaker_queue() RETURNS TRIGGER
    LANGUAGE plpgsql
    AS $$
    DECLARE
        active_speaker_queues INTEGER;
    BEGIN
        IF NEW.state = 'done'
            THEN
                SELECT COUNT(*)
                INTO active_speaker_queues
                FROM speaker_queue
                WHERE agenda_item_id = NEW.agenda_item_id
                AND (state = 'init' OR state = 'active');

                IF active_speaker_queues < 2
                    THEN
                        RAISE EXCEPTION 'Not enough speaker queues left. I cannot let you do that Dave.';
                        RETURN OLD;
                    ELSE
                        RETURN NEW;
                    END IF;
            ELSE
                RETURN NEW;
            END IF;
    END
    $$;

CREATE TRIGGER at_least_one_speaker_queue
    BEFORE UPDATE ON speaker_queue
    FOR EACH ROW
    EXECUTE PROCEDURE at_least_one_speaker_queue();

-- TODO: Make this work for the speaker table too.
-- It doesn't make any sense to add a speaker to a speakerqueue that isn't on the top of the stack.
CREATE FUNCTION check_if_top_speakerqueue() RETURNS TRIGGER
    LANGUAGE plpgsql
    AS $$
    DECLARE
        has_greater_friends BOOLEAN;
    BEGIN
        SELECT COUNT(sq2.id) > 0 INTO STRICT has_greater_friends
            FROM speaker_queue AS sq1
            JOIN speaker_queue AS sq2
            ON sq2.state = 'active'
            AND sq2.id > OLD.id
            AND sq1.agenda_item_id = sq2.agenda_item_id
            WHERE sq1.id = OLD.id;

        IF has_greater_friends
            THEN
                RAISE EXCEPTION 'This speaker queue is not on top of the stack!';
                RETURN OLD;
            ELSE
                RETURN NEW;
            END IF;
    END
    $$;

CREATE TRIGGER only_update_top_speakerqueue
    BEFORE UPDATE OF state ON speaker_queue
    FOR EACH ROW
    EXECUTE PROCEDURE check_if_top_speakerqueue();

CREATE FUNCTION may_only_add_or_update_speaker_to_init_or_active_speaker_queue() RETURNS TRIGGER
  LANGUAGE plpgsql
  AS $$
  DECLARE
    is_init_or_active BOOLEAN;
  BEGIN
    SELECT (state = 'init') OR (state = 'active') INTO is_init_or_active
    FROM speaker_queue
    WHERE id = NEW.speaker_queue_id;

    IF is_init_or_active
      THEN
        RETURN NEW;
      ELSE
        RAISE EXCEPTION 'You are trying to insert or update speakers on a done speaker queue. It is too late for that now.';
        RETURN OLD;
    END IF;
  END
  $$;

CREATE TRIGGER may_only_add_or_update_speaker_to_init_or_active_speaker_queue
  BEFORE INSERT OR UPDATE ON speaker
  FOR EACH ROW
  EXECUTE PROCEDURE may_only_add_or_update_speaker_to_init_or_active_speaker_queue();

CREATE FUNCTION websocket_news() RETURNS TRIGGER
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM model.send_websocket_notification(LOWER(TG_TABLE_NAME) || '_' || LOWER(TG_OP), row_to_json(NEW));
        RETURN NEW;
    END
    $$;

CREATE TRIGGER speaker_queue_news
    AFTER UPDATE OR INSERT ON speaker_queue
    FOR EACH ROW
    EXECUTE PROCEDURE websocket_news();

CREATE TRIGGER agenda_item_news
    AFTER INSERT OR UPDATE ON agenda_item
    FOR EACH ROW
    EXECUTE PROCEDURE websocket_news();

CREATE TRIGGER attendee_news
    AFTER INSERT OR UPDATE ON attendee
    FOR EACH ROW
    EXECUTE PROCEDURE websocket_news();

-- This is websocket_news() on steroids.
-- It does a join with active_speakers to give us the data we want
-- instead of the data we have, thus breaking the pattern the other
-- triggers follow.
CREATE FUNCTION speaker_news() RETURNS TRIGGER
    LANGUAGE plpgsql
    AS $$
    DECLARE
      j json;
    BEGIN
        SELECT row_to_json(r) INTO j
        FROM (
            SELECT s.id, s.speaker_queue_id, s.attendee_id, s.state, a.times_spoken, sq.agenda_item_id
            FROM speaker AS s
            LEFT JOIN active_speakers AS a
            ON s.id = a.id
            LEFT JOIN speaker_queue AS sq
            ON s.speaker_queue_id = sq.id
            WHERE s.id = NEW.id
        ) AS r;
        PERFORM model.send_websocket_notification(LOWER(TG_TABLE_NAME) || '_' || LOWER(TG_OP), j);
        RETURN NEW;
    END
    $$;

CREATE TRIGGER speaker_news
    AFTER INSERT OR UPDATE ON speaker
    FOR EACH ROW
    EXECUTE PROCEDURE speaker_news();

-- API RPC functions --------------------------------------------------------

-- Returns the id of the new current agenda item if things worked out well, 0 otherwise.
CREATE FUNCTION set_current_agenda_item(id INTEGER) RETURNS INTEGER
    LANGUAGE plpgsql
    AS $$
    DECLARE
        n INTEGER = 0;
    BEGIN
        IF EXISTS(SELECT 1 FROM agenda_item WHERE agenda_item.id=set_current_agenda_item.id) THEN
            UPDATE agenda_item SET state='done' WHERE state='active';
            UPDATE agenda_item SET state='active' WHERE agenda_item.id=set_current_agenda_item.id RETURNING agenda_item.id INTO n;
            RETURN n;
        ELSE
            RETURN 0;
        END IF;
    END
    $$;

REVOKE ALL ON FUNCTION set_current_agenda_item(id INTEGER) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION set_current_agenda_item(id INTEGER) TO admin_user;

-- Returns the id of the new current speaker if things worked out well, 0 otherwise.
CREATE FUNCTION set_current_speaker(id INTEGER) RETURNS INTEGER
    LANGUAGE plpgsql
    AS $$
    DECLARE
        n INTEGER = 0;
    BEGIN
        IF EXISTS(SELECT 1 FROM speaker WHERE speaker.id=set_current_speaker.id) THEN
            UPDATE speaker SET state='done' WHERE state='active';
            UPDATE speaker SET state='active' WHERE speaker.id=set_current_speaker.id RETURNING speaker.id INTO n;
            RETURN n;
        ELSE
            RETURN 0;
        END IF;
    END
    $$;

REVOKE ALL ON FUNCTION set_current_speaker(id INTEGER) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION set_current_speaker(id INTEGER) TO admin_user;

-- Public facing auth functions ---------------------------------------------

CREATE TYPE jwt_token AS (token TEXT);

CREATE FUNCTION api.login(username TEXT, password TEXT) RETURNS jwt_token
    LANGUAGE sql SECURITY DEFINER SET search_path = api, model, public, pg_temp
    AS $$
        -- Sign encrypts using HS256 by default.
        SELECT sign(row_to_json(r), current_setting('app.jwt_secret')) AS token
        FROM (
            SELECT
                role.name::TEXT AS role,
                extract(EPOCH FROM NOW())::INTEGER + 3600 AS exp,
                'r'::TEXT as mode
            FROM model.role
            RIGHT OUTER JOIN model.users ON (model.role.id = model.users.role_id)
            WHERE (username=username AND pwhash=model.crypt(password, pwhash))
        ) r;
    $$;

REVOKE ALL ON FUNCTION login(username TEXT, password TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION login(username TEXT, password TEXT) TO web_anon, lemmingpants;

-- Get token with permissions of web_anon.
-- Useful for websockets.
CREATE FUNCTION api.get_token() RETURNS jwt_token
  LANGUAGE sql SECURITY DEFINER SET search_path = api, model, public, pg_temp
  AS $$
    -- Sign encrypts using HS256 by default.
    SELECT sign(json_build_object('role', 'web_anon', 'exp', extract(EPOCH FROM NOW())::INTEGER + 3600, 'mode', 'r'),
        current_setting('app.jwt_secret')) AS token;
  $$;

REVOKE ALL ON FUNCTION get_token() FROM PUBLIC;
GRANT EXECUTE ON FUNCTION get_token() TO web_anon, lemmingpants;
