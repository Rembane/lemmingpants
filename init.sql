-- Initialization ------------------------------------------------------------
--
-- The role lemmingpants and the database lemmingpants must exist!

DROP SCHEMA IF EXISTS auth CASCADE;
CREATE SCHEMA auth;

DROP SCHEMA IF EXISTS api CASCADE;
CREATE SCHEMA api AUTHORIZATION lemmingpants;
GRANT ALL PRIVILEGES ON SCHEMA api TO lemmingpants;

DROP EXTENSION IF EXISTS pgcrypto CASCADE;
CREATE EXTENSION pgcrypto WITH SCHEMA auth;
DROP EXTENSION IF EXISTS pgjwt CASCADE;
CREATE EXTENSION pgjwt;

-- Internal tables ----------------------------------------------------------
--
-- It is really important that the users table is in the auth schema where
-- the users coming from HTTP can't reach it.

SET SCHEMA 'auth';

CREATE TABLE role (
    id   INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL
);

CREATE TABLE users (
    id       INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username TEXT NOT NULL,
    pwhash   TEXT NOT NULL,
    role_id  INTEGER REFERENCES role NOT NULL
);
CREATE UNIQUE INDEX ON users (lower(username));

SET SCHEMA 'api';

-- Public tables ------------------------------------------------------------

CREATE TABLE attendee (
    id      INTEGER UNIQUE PRIMARY KEY,
    cid     TEXT NOT NULL,
    name    TEXT NOT NULL,
    nick    TEXT NULL,
    created TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE agenda_item (
    id      INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title   TEXT NOT NULL,
    content TEXT NOT NULL,
    order_  INTEGER GENERATED BY DEFAULT AS IDENTITY,
    active  BOOLEAN DEFAULT FALSE NOT NULL
);
-- Only one agenda item may be active at the time.
CREATE UNIQUE INDEX ON agenda_item (active) WHERE active;

CREATE TABLE speaker_queue (
    id             INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    agenda_item_id INTEGER REFERENCES agenda_item NOT NULL
);

CREATE TABLE speaker (
    id               INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    speaker_queue_id INTEGER REFERENCES speaker_queue NOT NULL,
    attendee_id      INTEGER REFERENCES attendee NOT NULL,
    speaking         BOOLEAN DEFAULT FALSE NOT NULL,
    created          TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
-- At most one speaker per queue may be active at the time.
CREATE UNIQUE INDEX ON speaker (speaker_queue_id, speaking) where speaking;

-- API RPC functions --------------------------------------------------------

-- Returns the id of the new current agenda item if things worked out well, 0 otherwise.
CREATE FUNCTION api.set_current_agenda_item(id INTEGER) RETURNS INTEGER
    LANGUAGE plpgsql
    AS $$
    DECLARE
        n INTEGER = 0;
    BEGIN
        IF EXISTS(SELECT 1 FROM agenda_item WHERE agenda_item.id=set_current_agenda_item.id) THEN
            UPDATE agenda_item SET active=FALSE;
            UPDATE agenda_item SET active=TRUE WHERE agenda_item.id=set_current_agenda_item.id RETURNING agenda_item.id INTO n;
            RETURN n;
        ELSE
            RETURN 0;
        END IF;
    END
    $$;

REVOKE ALL ON FUNCTION set_current_agenda_item(id INTEGER) FROM PUBLIC;

-- Roles --------------------------------------------------------------------

GRANT ALL PRIVILEGES ON SCHEMA api TO lemmingpants;

DROP ROLE IF EXISTS web_anon;
CREATE ROLE web_anon NOLOGIN;
GRANT web_anon TO lemmingpants;

GRANT USAGE ON SCHEMA api TO web_anon;
GRANT USAGE ON ALL SEQUENCES IN SCHEMA api TO web_anon;
GRANT SELECT ON ALL TABLES IN SCHEMA api TO web_anon;

-- This user is used in the terminal interface.
DROP ROLE IF EXISTS insert_attendee_user;
CREATE ROLE insert_attendee_user NOLOGIN;
GRANT insert_attendee_user TO lemmingpants;
GRANT USAGE ON SCHEMA api TO insert_attendee_user;
GRANT SELECT, INSERT ON attendee TO insert_attendee_user;

DROP ROLE IF EXISTS admin_user;
CREATE ROLE admin_user NOLOGIN;
GRANT admin_user TO lemmingpants;

GRANT USAGE ON SCHEMA api TO admin_user;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA api TO admin_user;
GRANT ALL ON ALL TABLES IN SCHEMA api TO admin_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA api TO admin_user;

-- Auth functions ------------------------------------------------------------

SET SCHEMA 'api';

CREATE TYPE jwt_token AS (token TEXT);

CREATE FUNCTION api.login(username TEXT, password TEXT) RETURNS jwt_token
    LANGUAGE sql SECURITY DEFINER SET search_path = api, auth, public, pg_temp
    AS $$
        -- Sign encrypts using HS256 by default.
        SELECT sign(row_to_json(r), current_setting('app.jwt_secret')) AS token FROM (
            SELECT
                role.name::TEXT AS role,
                extract(EPOCH FROM NOW())::INTEGER + 3600 AS exp
            FROM auth.role
            RIGHT OUTER JOIN auth.users ON (auth.role.id = auth.users.role_id)
            WHERE (username=username AND pwhash=auth.crypt(password, pwhash))
        ) r;
    $$;

REVOKE ALL ON FUNCTION login(username TEXT, password TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION login(username TEXT, password TEXT) TO web_anon, lemmingpants;

-- Example data  -------------------------------------------------------------

SET SCHEMA 'auth';

INSERT INTO role(name) VALUES('web_anon');
INSERT INTO role(name) VALUES('insert_attendee_user');
INSERT INTO role(name) VALUES('admin_user');

INSERT INTO users(username, pwhash, role_id)
SELECT 'terminal', crypt('I will indeed be back.', gen_salt('bf', 8)), id FROM role WHERE name='insert_attendee_user';

INSERT INTO users(username, pwhash, role_id)
SELECT 'hen', crypt('grawr', gen_salt('bf', 8)), id FROM role WHERE name='admin_user';

SET SCHEMA 'api';

INSERT INTO attendee(id, cid, name) VALUES(1, 'ekeroot', 'A. Ekeroot');
INSERT INTO attendee(id, cid, name) VALUES(2, 'snelob', 'Snel Bob');
INSERT INTO attendee(id, cid, name) VALUES(3, 'bobbobson', 'Bob Bobsson');
INSERT INTO attendee(id, cid, name) VALUES(4, 'testson', 'Test Testson');
INSERT INTO attendee(id, cid, name) VALUES(5, 'doedsbengt', 'Döds Bengt');

INSERT INTO agenda_item(title, content, order_)
    VALUES('Mötets öppnande', 'Mötet bör öpnas med trumpetstötar och godis.', 1);
INSERT INTO agenda_item(title, content, order_)
    VALUES('Val av mötesordförande', 'Förslag: sittande.', 2);
INSERT INTO agenda_item(title, content, order_)
    VALUES('Val av reservmötesordförande ifall den första går sönder', 'Förslag: stående.', 3);
INSERT INTO agenda_item(title, content, order_)
    VALUES('Mer glass=?', 'JA! MER GLASS!!!', 4);
INSERT INTO agenda_item(title, content, order_)
    VALUES('Mer bäsk?', 'Mmmmmbäsk...', 5);
INSERT INTO agenda_item(title, content, order_)
    VALUES('Mötets stängande', 'Vi tänkte gå hem nu.', 6);
